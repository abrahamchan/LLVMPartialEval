\section{Related Work}
\label{sec:related-work}

Since Futamura~\cite{Futamura} first proposed the use of compile time partial evaluation in the 1970â€™s, various studies have explored and proposed different approaches to partial evaluation, with the goal of reducing program performance overhead through specialization. 
However, we find that these approaches differ significantly in maturity and effectiveness.
Smowton~\cite{Smowton} proposed one variant of partial evaluation by eliminating I/O operations to reduce the overhead caused by unnecessary disk I/O access. In his work, offline partial evaluation is used.
Nevertheless, the working process was complicated and remained a prototype.
Debois~\cite{Debois} proposed a method to remove code duplication in residual programs by specializing instrumented interpreters and using bisimulation to identify duplicated codes and remove them.
However, its use is limited to imperative languages only.
Jones~\cite{Jones1996} was the first to present a partial evaluation approach that specifically targets function calls and loop-invariant code.
In contrast to all of these prior works, Fujita~\cite{Fujita} simplified the problem of partial evaluation and presented a general approach - replace function arguments with constant values and apply traditional compiler passes. 

Software fault tolerance has been a widely studied topic.
Software system level reliability was discussed by Goel~\cite{Softwarereliability} by presenting an overview of the key reliability modelling approaches and analysis of the respective assumptions.
His work provided a procedure for fitting the fault model and illustrated it through an analysis of the models.
Subsequently, Randell~\cite{Randell} discussed and proposed a method for structuring complex computing systems with system-level fault tolerance techniques such as recovery blocks and fault-tolerant interfaces to facilitate the provision of error detection and recovery facilities. 
At the compiler level, SWIFT~\cite{SWIFT} implements software fault tolerance by instrumenting control flow checking mechanisms into programs.

More recently, fault injections have been used to measure the error resilience of programs.
Specifically, work in this area have used software implemented fault injections to achieve this goal.
Lu et al.~\cite{LLFI} have presented a LLVM-based fault injection tool, LLFI, and conducted runtime fault injections of different fault categories to quantify a program's error resilience.
Duraes et al.~\cite{Duraes2006} presented G-SWFIT, which also performs runtime fault injections on program binaries.
We have leveraged the work in this area to carry out a fault injection assessment of program error resilience. 

Although there has been extensive research on partial evaluation and software fault tolerance respectively, we have not yet seen the evaluation of system-level fault tolerance based on programs' partial evaluations.
