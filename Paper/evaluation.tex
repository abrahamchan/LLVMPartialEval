\section{Evaluation}
\label{sec:evaluation}

For evaluation, we focus on the actual performance of partial evaluation towards source code and the error resilience comparison between the unoptimized code and optimized code.
For partial evaluation performance, we will manually compare the IR code difference between the original code and the optimized code to see the lines of instruction reduction and instruction combination in the corresponding to quantify the result of partial evaluation.
For error resilience, we perform fault injection into the original and optimized code to test error resilience against a number of specified error types we manually set. 
We are going to use a LLVM based fault injector called LLFI~\cite{LLFI}.
LLFI ia a comprehensive fault injection aiming to inject simulated faults from real hardware and software environment such as faults like bit-flip which occurs mainly in the CPU ALU component and simulate stackoverflow errors which happens in real world software. It can injects a variety of hardware and software faults at the LLVM IR level using software implemented fault injection.

To simulate real world environment, we implement both software and hardware faults including bit flips, stuck-ats, buffer overflows, function argument corruptions and invalid pointer corruptions because the faults broadly represent a range of common hardware and software faults~\cite{V2005}, including permanent and transient faults. 

The whole evaluation process works as follows
\begin{itemize}
\item Apply partial evaluation optimization pass on the source code to generate optimized IR code
\item Implement the LLFI instrument tool for the optimized code to generate a a profiling executable and fault injection executable. The process generate an instrumented IR code which contains indexes towards the instructions and registers which can be fault injected.
\item Implement the LLFI profiling tool to profile the profiling executable to get the dynamic instruction counts during the actual execution, which will provide run-time fault-injection location and generate the golden run output for result analysis.
\item Implement the LLFI fault injector tool with specific error types mentioned above to conduct experiment and analyse output results.
\end{itemize}

As our planning, we will first try to finish the LLVM pass to run on simple snippet codes and then continue to work on more general codes. 
We first plan to run 1000 fault injections of each fault type on several C/C++ snippet and then real application code drawn from the Parboil~\cite{Parboil}, and SPEC CPU2006 benchmarks~\cite{SPEC} respectively.

After running the experiment, we will group and classify the effect results of injected faults on a program according to the following failure modes output comparing to the golden run: 
\begin{itemize}
\item Silent Data Corruptions (SDCs) 
\item Crashes/Hangs
\item Normal 
\end{itemize}

Then we will then report the failure rates (i.e SDCs / 1000) for each failure mode by fault type and the process is performed once for the unoptimized program (base case) and again for the program's partial evaluation.
As for error resilience criteria against the optimized code and the unoptimized code, we make hypothesize that the mean failure rate of a program's partial evaluation is statistically equal to the mean failure rate of the same unoptimized program and that will be judged as having the same error resilience and we consider the error resilience of program partial evaluations to be acceptable if the hypothesis holds across failure modes and fault types. Otherwise, we will see whether it is the error rate of optimized code or unoptimized code that have higher error rate to determine the actual result.

To realize this, we will perform a t-test to determine whether the means are statistically equivalent to each other, within a 95\% confidence interval using the mean failure rates from the two samples.

80\% Goal: We implement the partial evaluation optimization pass with minor limitations on LLVM and perform a small number of fault injection experiments.

100\% Goal: We implement the partial evaluation optimization pass on LLVM and perform fault injection experiments on several benchmarks. We compare the error resiliency between the unoptimized program and its partial evaluation through hypothesis testing. 
